# Hub CLI para Microsistemas (PowerShell version)
# Autogenerated to replace hub.py
#
# Este script actúa como un orquestador para gestionar las aplicaciones
# del sistema. Permite listar, ejecutar y verificar el estado de las apps.

$APPS_DIR = Join-Path $PSScriptRoot "apps"

<#
.SYNOPSIS
    Lista todas las aplicaciones disponibles en el directorio 'apps'.
.DESCRIPTION
    Escanea el directorio 'apps' en busca de subdirectorios que contengan 
    un archivo 'app.manifest.yml'. Parsea este archivo para mostrar
    información básica de la aplicación (ID, Nombre, Tipo, Puertos).
#>
function Get-Apps {
    Write-Host "Aplicaciones en Microsistemas" -ForegroundColor Cyan
    $formatString = "{0,-20} {1,-30} {2,-15} {3,-10}"
    Write-Host ($formatString -f "ID", "Nombre", "Tipo", "Puertos")
    Write-Host ("-" * 80)

    Get-ChildItem $APPS_DIR -Directory | ForEach-Object {
        $manifestPath = Join-Path $_.FullName "app.manifest.yml"
        if (Test-Path $manifestPath) {
            $id = $_.Name
            $content = Get-Content $manifestPath -Raw
            
            # Simple regex parsing for YAML (no external dependencies)
            $name = if ($content -match 'name:\s*["'']?([^"''\n\r]+)["'']?') { $Matches[1] } else { "N/A" }
            $type = if ($content -match 'type:\s*["'']?([^"''\n\r]+)["'']?') { $Matches[1] } else { "N/A" }
            
            # Ports parsing
            $ports = ""
            if ($content -match 'ports:\s*\n((\s+-\s*\d+\s*\n?)+)') {
                $portsList = $Matches[1] -split '\n' | ForEach-Object { if ($_ -match '-\s*(\d+)') { $Matches[1] } }
                $ports = $portsList -join ","
            }

            Write-Host ($formatString -f $id, $name, $type, $ports)
        }
    }
}

<#
.SYNOPSIS
    Ejecuta el comando de inicio de una aplicación.
.DESCRIPTION
    Lee el archivo 'app.manifest.yml' de la aplicación especificada por ID.
    Si encuentra la propiedad 'run_cmd', ejecuta ese comando en el directorio
    de la aplicación.
.PARAMETER appId
    El ID de la aplicación (nombre del directorio) a ejecutar.
#>
function Run-App {
    param([string]$appId)

    if ([string]::IsNullOrWhiteSpace($appId)) {
        Write-Host "Error: Debes especificar un ID de aplicación." -ForegroundColor Red
        return
    }

    $appPath = Join-Path $APPS_DIR $appId
    $manifestPath = Join-Path $appPath "app.manifest.yml"

    if (-not (Test-Path $manifestPath)) {
        Write-Host "Error: Aplicación '$appId' no encontrada o sin manifiesto." -ForegroundColor Red
        return
    }

    $content = Get-Content $manifestPath -Raw
    $runCmd = if ($content -match 'run_cmd:\s*["'']?([^"''\n\r]+)["'']?') { $Matches[1] } else { $null }
    $type = if ($content -match 'type:\s*["'']?([^"''\n\r]+)["'']?') { $Matches[1] } else { "N/A" }

    if (-not $runCmd) {
        if ($type -eq "static") {
            Write-Host "Info: La aplicación '$appId' es estática. Ábrela en tu navegador." -ForegroundColor Yellow
            return
        }
        Write-Host "Error: No se definió run_cmd para '$appId'." -ForegroundColor Red
        return
    }

    Write-Host "Iniciando $appId..." -ForegroundColor Green
    Set-Location $appPath
    Invoke-Expression $runCmd
}

<#
.SYNOPSIS
    Levanta una aplicación utilizando Docker Compose.
.DESCRIPTION
    Lee el archivo 'app.manifest.yml' de la aplicación especificada por ID.
    Si encuentra la propiedad 'compose_file', ejecuta 'docker compose up -d'
    utilizando ese archivo.
.PARAMETER appId
    El ID de la aplicación (nombre del directorio) a levantar.
#>
function Up-App {
    param([string]$appId)

    if ([string]::IsNullOrWhiteSpace($appId)) {
        Write-Host "Error: Debes especificar un ID de aplicación." -ForegroundColor Red
        return
    }

    $appPath = Join-Path $APPS_DIR $appId
    $manifestPath = Join-Path $appPath "app.manifest.yml"

    if (-not (Test-Path $manifestPath)) {
        Write-Host "Error: Aplicación '$appId' no encontrada." -ForegroundColor Red
        return
    }

    $content = Get-Content $manifestPath -Raw
    $composeFile = if ($content -match 'compose_file:\s*["'']?([^"''\n\r]+)["'']?') { $Matches[1] } else { $null }

    if (-not $composeFile) {
        Write-Host "Aviso: '$appId' no define un compose_file en su manifiesto." -ForegroundColor Yellow
        return
    }

    Write-Host "Levantando $appId con Docker Compose..." -ForegroundColor Green
    Set-Location $appPath
    docker compose -f $composeFile up -d
}

<#
.SYNOPSIS
    Realiza un chequeo de salud del entorno.
.DESCRIPTION
    Verifica la instalación de herramientas necesarias (Docker, Git, PHP),
    la existencia de archivos de configuración (.env, vendor), el estado
    de puertos clave y el estado de los contenedores Docker.
#>
function Invoke-Doctor {
    Write-Host "Chequeo de salud del Hub..." -ForegroundColor Cyan

    # 1. Herramientas Base
    $tools = @{
        "Docker" = "docker --version";
        "Git"    = "git --version";
        "PHP"    = "php --version"
    }

    foreach ($tool in $tools.Keys) {
        try {
            Invoke-Expression $tools[$tool] | Out-Null
            Write-Host "[OK] $tool instalado." -ForegroundColor Green
        } catch {
            Write-Host "[ERR] $tool no encontrado." -ForegroundColor Red
        }
    }

    # 2. Configuración
    if (Test-Path "$PSScriptRoot\.env") {
        Write-Host "[OK] Archivo .env encontrado." -ForegroundColor Green
    } else {
        Write-Host "[ERR] Archivo .env NO encontrado (copia .env.example)." -ForegroundColor Red
    }

    if (Test-Path "$PSScriptRoot\vendor") {
        Write-Host "[OK] Directorio vendor encontrado." -ForegroundColor Green
    } else {
        Write-Host "[ERR] Directorio vendor NO encontrado (ejecuta 'make install')." -ForegroundColor Red
    }

    # 3. Puertos (verificación básica de disponibilidad)
    $ports = @(8000, 8080)
    foreach ($p in $ports) {
        $tcpConn = Get-NetTCPConnection -LocalPort $p -ErrorAction SilentlyContinue
        if ($tcpConn) {
            Write-Host "[WARN] Puerto $p parece estar en uso." -ForegroundColor Yellow
        } else {
            Write-Host "[OK] Puerto $p libre." -ForegroundColor Green
        }
    }

    # 4. Estado de Contenedores Docker
    if (Get-Command docker -ErrorAction SilentlyContinue) {
        $containers = docker ps --format "{{.Names}}: {{.Status}}"
        if ($containers) {
            Write-Host "`nEstado de Contenedores:" -ForegroundColor Cyan
            $containers | ForEach-Object {
                if ($_ -match "healthy") {
                    Write-Host "  [OK] $_" -ForegroundColor Green
                } elseif ($_ -match "unhealthy") {
                    Write-Host "  [ERR] $_" -ForegroundColor Red
                } else {
                    Write-Host "  [INFO] $_" -ForegroundColor Yellow
                }
            }
        }
    }
}

$command = $args[0]
$subArg = $args[1]

switch ($command) {
    "list" { Get-Apps }
    "run"  { Run-App $subArg }
    "up"   { Up-App $subArg }
    "doctor" { Invoke-Doctor }
    default {
        Write-Host "Uso: .\hub.ps1 {list|run <id>|up <id>|doctor}"
        exit 1
    }
}
